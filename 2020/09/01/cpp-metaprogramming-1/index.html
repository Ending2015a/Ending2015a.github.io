<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">


<script data-ad-client="ca-pub-7507926436817293" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ending2015a.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>


  <meta name="description" content="發想最近在寫程式的時候遇到一個情景，讓我非常困擾。下面這個情況我不需要多加解釋，應該很多人也都有遇過類似這種困擾。 1234567891011121314151617void test_status(STATUS_t unknown_status)&amp;#123;    if(unknown_status &#x3D;&#x3D; STATUS_1 || unknown_status &#x3D;&#x3D; STATUS_3 || unk">
<meta property="og:type" content="article">
<meta property="og:title" content="[Note] C++ Metaprogramming: one_of">
<meta property="og:url" content="https://ending2015a.github.io/2020/09/01/cpp-metaprogramming-1/index.html">
<meta property="og:site_name" content="My Notes">
<meta property="og:description" content="發想最近在寫程式的時候遇到一個情景，讓我非常困擾。下面這個情況我不需要多加解釋，應該很多人也都有遇過類似這種困擾。 1234567891011121314151617void test_status(STATUS_t unknown_status)&amp;#123;    if(unknown_status &#x3D;&#x3D; STATUS_1 || unknown_status &#x3D;&#x3D; STATUS_3 || unk">
<meta property="og:locale" content="zh_TW">
<meta property="article:published_time" content="2020-09-01T11:26:08.000Z">
<meta property="article:modified_time" content="2020-09-02T12:14:26.086Z">
<meta property="article:author" content="Joe Hsiao">
<meta property="article:tag" content="Note">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Metaprogramming">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ending2015a.github.io/2020/09/01/cpp-metaprogramming-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-TW'
  };
</script>

  <title>[Note] C++ Metaprogramming: one_of | My Notes</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KZE22590KG"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-KZE22590KG');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">My Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分類</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜尋
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜尋..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Ending2015a" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-TW">
    <link itemprop="mainEntityOfPage" href="https://ending2015a.github.io/2020/09/01/cpp-metaprogramming-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.imgur.com/TBCKPn1.jpg">
      <meta itemprop="name" content="Joe Hsiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [Note] C++ Metaprogramming: one_of
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">發表於</span>

              <time title="創建時間：2020-09-01 19:26:08" itemprop="dateCreated datePublished" datetime="2020-09-01T19:26:08+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新於</span>
                <time title="修改時間：2020-09-02 20:14:26" itemprop="dateModified" datetime="2020-09-02T20:14:26+08:00">2020-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/Metaprogramming/" itemprop="url" rel="index"><span itemprop="name">Metaprogramming</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="閱讀次數">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">閱讀次數：</span>
              <span class="firestore-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="文章字數">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">文章字數：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="所需閱讀時間">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">所需閱讀時間 &asymp;</span>
              <span>1:22</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="發想"><a href="#發想" class="headerlink" title="發想"></a>發想</h2><p>最近在寫程式的時候遇到一個情景，讓我非常困擾。<br>下面這個情況我不需要多加解釋，應該很多人也都有遇過類似這種困擾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_status</span><span class="params">(STATUS_t unknown_status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(unknown_status == STATUS_1 || unknown_status == STATUS_3 || unknown_status == STATUS_5 || unknown_status == STATUS_7)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do some stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(unknwon_status == STATUS_2 || unknown_status == STATUS_3 || unknown_status == STATUS_4)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do some stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(unknwon_status == STATUS_5 || unknwon_status == STATUS_6 || unknwon_status == STATUS_9 || unknwon_status == STATUS_11 || unknwon_status == STATUS_27 || unknwon_status == STATUS_38)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do some stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>當你遇到狀況 1、3、5、7 時要處理一些事情，遇到狀況 2、3、4 時要處理一些事情，最後遇到狀況 5、6、9、11、27、38 的時候又要再處理一些事情….，可能有些人遇到的，後面還要再拉更多的 if 跟重複寫一堆相同且沒有意義的變數名 (unknown_status) 跟operator (||)。不但程式變得很長，不容易閱讀，你也很容易在寫這一長串的時候不小心出錯，例如 operator == 寫成 operator = ，結果還 de 不出 bug，諸如此類的小陷阱。</p>
<p>當然你可以抱怨說，到底是誰這麼沒水準，定義這種沒有規則的 STATUS。但是有時候可能你因為一些被限制的因素而只能使用這種不符合你預期的規則的 lib ，你也無從選擇只好接受。</p>
<p>於是就讓我萌生了一些想法：<strong>我有沒有辦法用一個很簡單的表達式來省略掉這些高度重複的變數名、還有 operator</strong>。當然其實我早就知道這是可行的，而且方法非常多，隨便想都可以想的到 3~5種偷懶的方法，像是開個 vector 把狀況們都捆成一包，再用 for 回圈去檢查、或是用 std::any_of 搭配 lambda function 的方式解決，又甚至自己重新 mapping 一次 STATUS，變成可以使用 Binary OR 的方式檢查。</p>
<p>問題就在於，我要如何在解決問題的同時又能夠解決的<strong>漂亮</strong>，這是一個很大的問題。我當然我也可以選擇不動腦就寫一堆垃圾 Code 來解決這種不起眼的小問題，但是這就不是我的 Style 啦。於是我決定要動手設計了一個新的 operator (我稱他是 operator 啦，雖然他只是一堆 function 跟 struct 的疊加)，這個 operator 的特點就是看起來要極其順眼，非常容易使用，最重要的是<strong>在 compile 之後的效能要能夠跟原本的暴力破解垃圾 Code 不相上下。</strong></p>
<p>於是我第一個想到的 operator 就是 one_of，這是我的目標：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_status</span><span class="params">(STATUS unknown_status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(unknown_status == one_of(STATUS_1, STATUS_3,</span><br><span class="line">                                STATUS_5, STATUS_7))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do some stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(unknwon_status == one_of(STATUS_2, STATUS_3, STATUS_4))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do some stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(unknwon_status == one_of(STATUS_5, STATUS_6,</span><br><span class="line">                                STATUS_9, STATUS_11,</span><br><span class="line">                                STATUS_27, STATUS_38))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do some stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跟原本的寫法比起來是不是變得更順眼、更易讀、更易寫（不容易出錯）？這個 operator 非常口語化的詮釋了我想做的事情：</p>
<ul>
<li>if: 當</li>
<li>unknown_status: 某變數</li>
<li>==: 等於</li>
<li>one_of: 下列其中一個</li>
<li>STATUS_1, STATUS_3, STATUS_5, STATUS_7</li>
<li>我就 do some stuff</li>
</ul>
<h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(unknown_status == one_of(STATUS_1, STATUS_3,</span><br><span class="line">                            STATUS_5, STATUS_7))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//do some stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我想要定義一個新的 operator one_of 來解決掉一堆難看的垃圾 Code 問題。而且他擁有以下特點：</p>
<ul>
<li>易寫、易讀</li>
<li>可以接受不定個數的參數 (可以使用 parameter pack 實現)</li>
<li>可以接受任何型態 (可以使用 template 實現)</li>
<li>編譯後效能可以跟原本的垃圾 Code 一樣好 (metaprogramming 實現)</li>
</ul>
<p>你看看，從上列開出的特點來看，就是只能用 metaprogramming 實現了。</p>
<h2 id="實現"><a href="#實現" class="headerlink" title="實現"></a>實現</h2><p>好了，現在有了目標，問題就在於要如何實現這個 one_of？</p>
<p>首先，可以看的出來，我們要把 unknown_status 跟 one_of(…) 做比較，能做到的方法其實就幾個：第一個是 one_of 可能是一個 struct/class，他的 Constructor 能夠接納無限個 parameters，然後我拿某個變數 unknown_status 跟這個 struct/class 做 <code>==</code> 比較 (operator overloading)。第二個是 one_of 可能是一個 function，他能夠接納無限個 parameters，呼叫後會回傳一個包好的 struct/class (我傳入的 parameters 都在裏面)，然後再用 unknown_status 去跟這個 struct/class 做 <code>==</code> 比較 (operator overloading)。</p>
<p>我們使用第一個方法來實作，流程是這樣，one_of 的 constructor 可以接受 parameter pack，之後我們將 parameter pack 存到 <code>std::tuple</code> 裏面放著，等到呼叫 == 時再從 <code>std::tuple</code> unpack 一個一個做判斷：</p>
<p>所以第一步先建立好 one_of 的 constructor (這邊使用 struct 是因為 struct 的 member 預設是 public，我們不需要再多一步用 <code>public:</code> 來指定)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">one_of</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    one_of(Ts&amp;&amp;...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊的語法 <code>typename...Ts</code> 就是 parameter pack，意思就是我會傳入不定個數的參數。不多解釋，不懂的自己去 <code>google</code>。接下來我們要把傳進來的參數 <code>args</code> 包成一份 <code>std::tuple</code>，而因為 <code>std::tuple</code> 也需要不定個數的欄位，我們勢必必須把 <code>struct one_of</code> 也宣告成 template struct：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">one_of</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;ArgTypes...&gt; args;  <span class="comment">//tuple</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    one_of(Ts&amp;&amp;...args) : args(<span class="built_in">std</span>::forward&lt;Ts&gt;(args)...)&#123;&#125;;  <span class="comment">// constructor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>這邊我們使用 <code>std::tuple</code> 因此我們必須 <code>#include &lt;tuple&gt;</code>，還有我們使用 <code>std::forward</code> 來 unpack parameter pack 變成一列 arguments 傳進 tuple 的 constructor 裏面結束這回合，因此我們還必須 <code>#include &lt;utility&gt;</code>。</p>
<p>但是接下來我意識到一件事情，如果我們使用這種方法來設計我們的 one_of 的話，由於現在 one_of struct 已經變成 template struct 了，到時候呼叫的方法就會變成:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(unknown_status == one_of&lt;STATUS_t, STATUS_t, STATUS_t, STATUS_t&gt;(STATUS_1, STATUS_3, STATUS_5, STATUS_7))</span><br></pre></td></tr></table></figure></p>
<p><em>喔不！</em> 我們必須指定傳入參數的型態給 template！這可不是我們當初所預期的 one_of 啊！<br>但是不用擔心，他還有救，讓我們來給他包上一層 helper function：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">type_one_of</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;ArgTypes...&gt; args;  <span class="comment">//tuple</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    _type_one_of(Ts&amp;&amp;...args) : args(<span class="built_in">std</span>::forward&lt;Ts&gt;(args)...)&#123;&#125;;  <span class="comment">// constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line">constexpr auto one_of(ArgTypes&amp;&amp;... args) -&gt; _type_one_of&lt;ArgTypes...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _type_one_of&lt;ArgTypes...&gt;(<span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我做了什麼事情呢？<br>首先，我把 <code>struct one_of</code> 改名了，改成 <code>struct _type_one_of</code> 接著我新增了一個 helper function 就是我們最愛的互動介面 <code>one_of</code>。他的功能就是當我們傳入參數到 one_of 時他會幫我們建立一個包好的 <code>struct _type_one_of</code> 這樣我們就不用自己手動包了！</p>
<p>helper function 的 return type 是 <code>_type_one_of&lt;ArgTypes...&gt;</code> 而使用 <code>-&gt;</code> 的寫法稱做 trailing return type，他只是可以延後到 function declaration 後面才指定 return type，在這個 case，這樣寫跟把 return type 寫在前面其實沒有差別，單純只是我覺得因為 return type 長的比較醜，放在後面這樣比較好看。而回傳的東西一樣就是把東西 unpack。</p>
<p>除此之外，在寫 metaprogramming 的時候要記得，你希望 compiler 自動幫你拆開來的 function 都要加上 <code>constexpr</code> specifier，這樣 compiler 才會盡可能幫你拆開。而 <code>std::forward</code> 這個 function，很幸運的在 c++ 14 的時候已經改成 <code>constexpr</code>，因此這個 constructor 我很有信心 compiler 絕對會幫我們拆開來。</p>
<p>這樣就完成了我們的 one_of，接下來是要寫 <code>==</code> 的部份。我們可以用 operator overloading 來自定義一個 <code>operator==</code>，把任意 type 跟 <code>struct _type_one_of</code> 做比較：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> _type_one_of&lt;ArgTypes...&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.__match_op(lhs, rhs.args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這邊我們定義好了 <code>operator==</code> 的部份，而接下來因為我們需要把預先存起來的 <code>std::tuple</code> 拿出來用，因此我希望我們可以把 unpack tuple 的部份使用 struct 內部的 function 來實現。當然你也可以不要像我一樣，你也可以直接把 function 定義在外面。</p>
<p>接下來實作 unpack tuple 的部份，回到 <code>struct _type_one_of</code> 裏面：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">type_one_of</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;ArgTypes...&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    _type_one_of(Ts&amp;&amp;... args): args(<span class="built_in">std</span>::forward&lt;Ts&gt;(args)...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> Inds = <span class="built_in">std</span>::make_index_sequence&lt;<span class="keyword">sizeof</span>...(Ts)&gt;&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_op_impl(lhs, tup, Inds&#123;&#125;); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先我們在 <code>operator==</code> 裏面呼叫了 <code>__match_op</code> 這個 function，因此我們定義一下 <code>__match_op</code> 。第一個參數是型別為 <code>T</code> 的 <code>lhs</code> (left-hand-side)，第二個是我們的 tuple <code>tup</code>。然後我們產生一個 <code>std::integer_sequence</code>，並且呼叫 <code>__match_op_impl</code>。</p>
<p><code>std::make_index_sequence</code> 定義在 <code>&lt;utility&gt;</code>，是 c++ 14 才有的 type。他的功能是可以產生一個 template parameters 為一個數列的 class。而 <code>sizeof...(Ts)</code> 是 c++ 11 的語法，他其實是叫作 <code>sizeof...</code> operator，用途是計算 parameter pack 裏面元素的數量。因此當我呼叫 <code>std::make_index_sequence&lt;sizeof...(Ts)&gt;</code> 時，假設 <code>Ts</code> 裏面有 5 個元素，他會產生一個長的像這樣的 type：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::index_sequence&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure><br>然後我們定義 template 的最後一個 parameter type 的預設 type 是這個東西，這樣我們就得到<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> Inds = <span class="built_in">std</span>::index_sequence&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure><br>這個 Inds 是一個 class，因此我們在呼叫 <code>__match_op_impl</code> 並把他當參數傳入時，使用 <code>Inds&#123;&#125;</code> 等於是創建一個 object 的 instance。</p>
<p>之所以要用這種二段式呼叫的原因主要是因為 <code>std::tuple</code> 限制的關係，如果要取得 tuple 裏面的元素，我們必須使用 <code>std::get</code> 這個 function，而 <code>std::get</code> 這個 function 會需要指定元素的 Index。例如，如果要取出 tuple 的第<code>N</code>個元素，則我們必須這樣寫：<code>std::get&lt;N&gt;(tup)</code>。因此，我們利用兩段式呼叫，第一次呼叫先用 <code>std::make_index_sequence</code> 取得元素 Index 的 sequence 後再進行第二次呼叫，unpack tuple。</p>
<p>接下來是定義<code>__match_op_impl</code> 的部份：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">type_one_of</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;ArgTypes...&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    _type_one_of(Ts&amp;&amp;... args): args(<span class="built_in">std</span>::forward&lt;Ts&gt;(args)...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="built_in">std</span>::<span class="keyword">size_t</span>... I&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op_impl(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup, <span class="built_in">std</span>::index_sequence&lt;I...&gt;) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_one_of_op(lhs, <span class="built_in">std</span>::get&lt;I&gt;(tup)...); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> Inds = <span class="built_in">std</span>::make_index_sequence&lt;<span class="keyword">sizeof</span>...(Ts)&gt;&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_op_impl(lhs, tup, Inds&#123;&#125;); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>這邊我們定義了 <code>__match_op_impl</code> 函數，一樣，第一個參數是 <code>lhs</code>，第二個是 tuple <code>tup</code>，第三個是 Index sequence，他的 type 是 <code>std::index_sequence&lt;I...&gt;</code> 由於實體變數我們並不是很 care (甚至這個 class 裏面根本沒包多少東西，重點是他的 template parameter pack)，所以我們第三個參數只寫 type 而沒有寫 variable 的名稱。我們在 template 裏面定義 Index sequence 的 template parameter pack <code>std::size_t... I</code>。這樣我們就可以用 <code>std::get&lt;I&gt;(tup)...</code> 來讓 Compiler 自動幫我們 unpack tuple。</p>
<p>接著我們呼叫 <code>__match_one_of_op</code>，我們第一個參數傳入 <code>lhs</code>，後面的參數則是用 <code>...</code> 來 unpack。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_one_of_op(<span class="keyword">const</span> T&amp; lhs, ArgTypes&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) == <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">false</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> any( (lhs == <span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)) ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊我們定義 <code>__match_one_of_op</code> 的內容，首先這先使用了一個 <code>if constexpr else</code> 的表達式，從 c++ 17 開始可以指定 if else 是 <code>constexpr</code>，這樣 compiler 就會幫我們拆開來。而如果你想要使用 <code>constexpr</code> 的 <code>if</code> <code>else if</code> <code>else</code> 的話，你可以這樣寫：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="comment">/*...*/</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span> <span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="comment">/*...*/</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span></span></span><br></pre></td></tr></table></figure><br>實際上 <code>else if</code> 就是 <code>else&#123; if(/*...*/)&#123;&#125; &#125;</code>。</p>
<p>如果 <code>sizeof...(args) == 0</code> 的話，也就是如果 parameter pack 裏面一個東西都沒有，我們直接 return false。否則我們要把 <code>args</code> 用 <code>...</code> 拆開來一個一個跟 <code>lhs</code> 做比較。</p>
<p>到這邊，如果 compiler 把 any 裏面的東西拆開來，他會得到類似這樣的東西 (這只是pseudocode)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any( lhs&#x3D;&#x3D;args[0], lhs&#x3D;&#x3D;args[1], lhs&#x3D;&#x3D;args[2], ...) </span><br></pre></td></tr></table></figure></p>
<p>而由於我們當初定義 <code>one_of</code> 是：<strong>只要其中一項等於 <code>lhs</code></strong> 就會回傳 <code>true</code>，因此我們可以寫一個 <code>any</code> 這個 function 來負責統整所有比較的結果，只要有其中一個 expression 是 <code>true</code>，則 <code>any</code> 會回傳 <code>true</code>，否則回傳 <code>false</code>。</p>
<p>因此我們定義 <code>any</code> 這個 function<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">(ArgTypes&amp;&amp;... args)</span> </span>&#123; <span class="keyword">return</span> (... || args); &#125;</span><br></pre></td></tr></table></figure></p>
<p>這邊我們使用 c++ 17 的語法 <code>(... || args)</code> 這個語法叫作 fold expression，他的用途就是他會把 parameter packs 拆開後中間全部用同樣的 <strong>operator</strong> 連接起來，因此會得到類似這樣的效果 (這只是pseudocode)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(... args[2] || args[1] || args[0])</span><br></pre></td></tr></table></figure></p>
<p>這邊需要注意的是我寫成 left fold 的型式，但其實也可以使用普通的 right fold 型式<br><code>(args || ...)</code>。差別只在於展開的方向不同。</p>
<p>left fold:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(... args[2] || args[1] || args[0])</span><br></pre></td></tr></table></figure></p>
<p>right fold:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(args[0] || args[1] || args[2] ...)</span><br></pre></td></tr></table></figure></p>
<p>詳細請看：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/fold">fold expression(since C++17) - cppreference.com</a></p>
<p>到這邊我們就真正完成了我們的 one_of operator，下面是完整的 code：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">(ArgTypes&amp;&amp;... args)</span> </span>&#123; <span class="keyword">return</span> (... || args); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_one_of_op(<span class="keyword">const</span> T&amp; lhs, ArgTypes&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) == <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">false</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> any( (lhs == <span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)) ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">type_one_of</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;ArgTypes...&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    _type_one_of(Ts&amp;&amp;... args): args(<span class="built_in">std</span>::forward&lt;Ts&gt;(args)...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="built_in">std</span>::<span class="keyword">size_t</span>... I&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op_impl(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup, <span class="built_in">std</span>::index_sequence&lt;I...&gt;) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_one_of_op(lhs, <span class="built_in">std</span>::get&lt;I&gt;(tup)...); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> Inds = <span class="built_in">std</span>::make_index_sequence&lt;<span class="keyword">sizeof</span>...(Ts)&gt;&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_op_impl(lhs, tup, Inds&#123;&#125;); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line">constexpr auto one_of(ArgTypes&amp;&amp;... args) -&gt; _type_one_of&lt;ArgTypes...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _type_one_of&lt;ArgTypes...&gt;(<span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> _type_one_of&lt;ArgTypes...&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.__match_op(lhs, rhs.args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接著你可以試試看使用這個程式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; g;</span><br><span class="line">    <span class="keyword">if</span>(g == one_of(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;It&#x27;s a multiple of 10 !&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>one_of 裏面可以塞不定個數的參數</li>
<li>one_of 可以塞任何型態的變數</li>
</ul>
<p>你可以在<a target="_blank" rel="noopener" href="https://godbolt.org/z/LjS1WS">這邊</a> 比較一下看看編譯後的結果是不是跟原本的垃圾 Code 一模一樣。</p>
<p>除此之外，因為我們使用 template parameter pack 的關係，one_of 可以傳入每個型態都不一樣的參數：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; g;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">35</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> f = <span class="number">12.6</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> d = <span class="number">-4.9</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd&#123;<span class="number">-1.4</span>, <span class="number">6.8</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(g == one_of(i, f, d, str, vd)) <span class="comment">// int, float, double, string, vector</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;g is in the set !&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是這樣你必須自己 overload 不同型態間的 operator==，不然 compile 的時候會出錯。</p>
<h2 id="進階"><a href="#進階" class="headerlink" title="進階"></a>進階</h2><h3 id="做比較測試"><a href="#做比較測試" class="headerlink" title="做比較測試"></a>做比較測試</h3><p>雖然 one_of 已經可以跟任意型態做比較了，但是實際上這麼做是非常危險的。如上所言，有時候使用者並不會記得要實作出對應任意型態的 operator==，甚至，為每一對型態實作一組 operator== 是非常費時的時間，因此我們有沒有辦法寫個功能讓 compiler 自動判定兩個型態能不能做 == 比較，如果可以的話就做比較，不行的話就回傳 <code>false</code>？</p>
<p>這裡我們就必須使用一個 metaprogramming 的特殊技巧叫作 <strong>SFINAE</strong>，他的核心理念就是實作一個 General 的 template，再實作一個專做測試用的 Specialized template，如果我們想要的功能能夠吻合到 Specialized template 表示測試合格(e.g. 測試某 Type 擁有某個 member、測試某 Type 有支援某 Operator等等)，如果不合格，Compiler 也會自動把他吻合到 General 的 template 上面而不會跳出 Compiler error。這個的運作原理不難理解，我在這邊就不多做解釋，想知道的自行 <code>google</code>。</p>
<p>因此我們繼續更改 Code，我希望在 <code>__match_one_of_op</code> 裏面呼叫 <code>any</code> 前先加入比較測試，<strong>讓 Compiler 幫我們檢查</strong>兩個型態能不能做比較 <em>(重點：要 Compiler 幫我們檢查！)</em>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_one_of_op(<span class="keyword">const</span> T&amp; lhs, ArgTypes&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) == <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">false</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> any( (__match_comparable_one_of_op(lhs, args)) ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這邊我們直接呼叫<code>__match_comparable_one_of_op</code> 並用 <code>...</code> 來幫我們逐一配對檢查看能不能做比較。</p>
<p>這邊的實作方式非常多，我們也可以使用 tag dispatching 、SFINAE、或是<code>std::enable_if</code> 的方式實作，也可以直接用 <code>if constexpr else</code> 的方式實作，而這次我們就先從簡用 <code>if constexpr else</code> 的方式實作。實際上我覺得用 SFINAE 實作我覺得比較優美，因為在 metaprogramming 中出現 <code>if else</code> 這種東西在瀏覽 Code 的時候感覺就是特別礙眼。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;LT, RT&gt;::value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> lhs</span>==rhs;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這邊首先使用 struct type 的 SFINAE <code>_whether_support_op</code> 來判斷 <code>LT</code> 跟 <code>RT</code> 這兩個型態能不能做比較。<br>註：SFINAE 也有 function type 的，有機會再介紹。</p>
<p>如果 <code>LT</code> 跟 <code>RT</code> 可以做比較，則回傳 <code>lhs == rhs</code> 比較結果，否則回傳 <code>false</code>。這邊注意因為他是 <code>constexpr</code> specified 的 <code>if else</code> 因此如果 <code>if</code> 的條件不成立則 Compiler 不會編譯 <code>if</code> 裏面的內容。有需要的話，我們甚至可以印出一些資訊來看看程式的運作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;LT, RT&gt;::value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[Comparable] &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> lhs==rhs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[Not Comparable] &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下來就是實作 struct 型的 SFINAE <code>_whether_support_op</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;&gt;&gt;</span><br><span class="line">struct _whether_support_op : <span class="built_in">std</span>::false_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;LT, RT, std::void_t&lt;</span></span><br><span class="line"><span class="class">        decltype(std::declval&lt;LT&gt;()==std::declval&lt;RT&gt;) &gt;&gt; :</span> <span class="built_in">std</span>::true_type</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我也是最近才注意到 c++ 17 中出現了一個新的 Type 叫作 <code>std::void_t</code> 而且根據 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/void_t">cppreference.com</a> 的資訊，這個 Type 就是專門拿來玩 SFINAE 的！由於 <code>std::false_type</code>、<code>std::true_type</code>、<code>std::void_t</code> 都是出自 <code>&lt;type_traits&gt;</code> ，因此必須加上 <code>#include &lt;type_traits&gt;</code>。而 <code>std::void_t</code> 其實有個很有趣的事情就是不管我們塞入什麼型態，最後的 Type 他都會是 void。他的定義類似這樣：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">void_t</span> = <span class="keyword">void</span>;</span><br></pre></td></tr></table></figure></p>
<p>所以不管我們塞什麼型態給他，他都是 void。</p>
<p>首先先從 General 的 <code>struct _whether_support_op</code> 開始 (他其實有個名字叫作 primary template)，這邊定義他的 template 參數是 <code>&lt;typename, typename, typename = std::void_t&lt;&gt; &gt;</code>。之所以都不寫名字是因為我們根本不 care 那個變數型態（簡稱變態）叫作什麼名字，反正他就是會有三個變態進來，然後第三的變態預設為 <code>std::void_t&lt;&gt;</code>就是為了玩 SFINAE 用的。</p>
<p>如果 Compiler 在配對 <code>_whether_support_op</code> 的時候配對到這個 General 版的 ，就表示我們想要的功能無法使用，因此我們讓這種 General 版的 struct 繼承 <code>std::false_type</code>。繼承這個 <code>std::false_type</code> 的時候，<code>_whether_support_op</code> 會繼承到一個 <code>static member</code> 叫作 <code>value</code>，而且 <code>value</code> 值會是 <code>false</code>。因此當我們呼叫 <code>_whether_support_op&lt;LT, RT&gt;</code> 後去取得他的 <code>value</code> 值，會得到 <code>false</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(<span class="literal">false</span> == _whether_support_op&lt;LT, RT&gt;::value);</span><br></pre></td></tr></table></figure></p>
<p>接下來定義一個 Specialized 的 struct <code>_whether_support_op</code> (specialized template)，這邊 template 只需要定義兩個變態 <code>&lt;typename LT, typename RT&gt;</code> 就可以了，因為第三個變態是我們要玩 SFINAE 用的。接下來就是客製化，這個行為稱做 partial specialization，我們只真對部份的變態做 specialization：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;LT, RT, std::void_t&lt;/*..specialize..*/&gt; &gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出，<code>LT</code>、<code>RT</code> 前兩個變態沒有特別 specialize， 但是第三個變態，我們指定他是 <code>std::void_t</code>，並且在 <code>std::void_t</code> 的 template 變態塞入 <code>decltype(std::declval&lt;LT&gt;()==std::declval&lt;RT&gt;)</code>。如果 Compiler 成功配對這個 struct 的話，他會使用這個 specialized 的 struct，而這個 specialized 的 struct 有繼承 <code>std::true_type</code>， 同 <code>std::false_type</code>，如果去取他的 <code>value</code> 值會得到 <code>true</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(<span class="literal">true</span> == _whether_support_op&lt;LT, RT&gt;::value);</span><br></pre></td></tr></table></figure></p>
<p>至於，解釋 <code>decltype(std::declval&lt;LT&gt;()==std::declval&lt;RT&gt;)</code> 這一串東西是什鬼，要先從 <code>decltype</code> 開始解釋。<code>decltype</code> 跟 <code>std::declval</code> 都不是新東西了，他們在 c++ 11就存在了。<code>decltype</code> 的用途是可以得到 <code>decltype(expression)</code> 裏面 expression 的回傳型態。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z = x+y;</span><br></pre></td></tr></table></figure><br>我們可以知道 <code>x</code> 和 <code>y</code> 都是 <code>int</code> 型態，所以 <code>x+y</code> 也會回傳 <code>int</code> 型態，利用 <code>decltype</code> 這個 operator，可以得到 <code>x+y</code> 的回傳型態 <code>int</code> 之後再宣告一個新變數 <code>z</code>，<code>z</code> 的型態就會是 <code>int</code>。</p>
<p><code>std::declval</code> 定義在 <code>&lt;utility&gt;</code> 裏面，他可以將一個指定的 Type 轉換成該 Type 的 Reference type，但是他並不會呼叫該 Type 的 Constructor，藉此我們可以呼叫他的 member function。所以 <code>std::declval&lt;LT&gt;()</code> 跟 <code>std::declval&lt;RT&gt;()</code> 就會分別產生一個 <code>LT</code>、<code>RT</code> 的 reference type <code>LT&amp;&amp;</code> 跟 <code>RT&amp;&amp;</code> ，我們可以呼叫他們的 member function，或是 operator。但是要注意的是，並不是只要用 <code>std::declval</code> 就可以無限上綱，首先他不會產生一個實體的 instance/object，再來就是他只能用在類似 <code>sizeof</code>、<code>decltype</code> 這類只需要 function definition 的 specifier 上，以及他還有一些規則，如果傳入的變態是 non cv-qualified (非 const 或 volatile) 或是 non ref-qualified (非 lvalue type <code>&amp;</code>) 則會回傳 rvalue type <code>&amp;&amp;</code>，而如果傳入的參數是cv-qualified 或是 ref-qualified 則會回傳同樣的變態。詳細的自己 <code>google</code>。</p>
<p>總之，當我們呼叫 <code>std::declval&lt;LT&gt;()</code> 跟 <code>std::declval&lt;RT&gt;()</code> 時 Compiler 會產生這兩的變態的 reference type 接著使用 <code>std::declval&lt;LT&gt;() == std::declval&lt;RT&gt;()</code> 嘗試呼叫這兩個變態的 operator==，然後取得回傳的變態 <code>decltype(std::declval&lt;LT&gt;() == std::declval&lt;RT&gt;())</code>，然後將這個變態放入 <code>std::void_t&lt;...&gt;</code>，最後放入 struct <code>_whether_support_op</code> 的第三個 argument。</p>
<p>當我們從外部宣告一個實體 struct 時 (e.g. <code>_whether_support_op&lt;int, std::string&gt;</code> )，Compiler 會發生一系列事情，這邊就會關係到 Compiler 在呼叫 template function 或 template class 的決策流程：</p>
<ul>
<li>第一個階段會先進行 name lookup，找出對應名稱的 function / class</li>
<li>第二個階段會進行 template argument deduction，推導出所有 candidate function / class</li>
<li>第三個階段會進行篩選，選出最吻合的 function / class</li>
</ul>
<p>詳細請看：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">Template argument deduction - cppreference.com</a></p>
<p>以我們的例子來說，第一個階段的 name lookup，Compiler 可以得到我們有兩個 <code>_whether_support_op</code> 的 template struct。</p>
<p>第二個階段 argument deduction 就會產生變化了，首先他會將指定的型態 <code>int</code> 跟 <code>std::string</code> 帶入第一個 <code>_whether_support_op</code> (注意，到這邊為止，Compiler 都還不知道誰是 primary 誰是 specialized)。由於我們只有指定兩個型態，第三個我們使用預設的 <code>typename = std::void_t&lt;&gt;</code>，Compiler 會產生第一個可行的候選名單 <code>_whether_support_op&lt;int, std::string, void&gt;</code>，但是注意，這個候選名單第三個變態是 default，而非在宣告時指定的。</p>
<p>接下來 deduce 第二個 <code>_whether_support_op</code> 會產生兩種狀況。<br>狀況一：如果我們有宣告 <code>LT</code> 與 <code>RT</code> 的 operator==，則 <code>std::declval&lt;LT&gt;() == std::declval&lt;RT&gt;()</code> 判斷式會成立，<code>decltype</code>可以得到正確的回傳變態 (通常是 <code>bool</code>)，接著 <code>std::void_t&lt;bool&gt;</code> 也能夠正常成立，最後得到完整的 <code>_whether_support_op&lt;int, std::string, void&gt;</code>，這邊的第三個變態就是宣告時指定的，他是從 <code>std::void_t&lt;&gt;</code> 特化成 <code>void</code> 的，因此 Compiler 會把這個 struct 判斷成是一種 specialization。而 specialized template 的優先權會大於 primary template，因此 Compiler 最後會選擇這個 template。這時候我們取出 <code>value</code> 值會得到 <code>true</code>。</p>
<p>狀況二：如果我們沒有宣告 <code>LT</code> 與 <code>RT</code> 的 operator==，則 <code>std::declval&lt;LT&gt;() == std::declval&lt;RT&gt;()</code> 判斷式無法成立，<code>decltype</code> 得不到正確的回傳變態，<code>std::void_t&lt;...&gt;</code> 也無法成立，最後 Compiler 沒有辦法得到完整的 specialization，因此這個 struct 就會被 Compiler 從 candidate list 裏面剔除。Compiler 最後選擇使用 primary template。這時候我們取出 <code>value</code> 值會得到 <code>false</code>。</p>
<p>最後的程式碼：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">(ArgTypes&amp;&amp;... args)</span> </span>&#123; <span class="keyword">return</span> (... || args); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;&gt;&gt;</span><br><span class="line">struct _whether_support_op : <span class="built_in">std</span>::false_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;LT, RT, std::void_t&lt;</span></span><br><span class="line"><span class="class">        decltype(std::declval&lt;LT&gt;()==std::declval&lt;RT&gt;) &gt;&gt; :</span> <span class="built_in">std</span>::true_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;LT, RT&gt;::value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> lhs</span>==rhs;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_one_of_op(<span class="keyword">const</span> T&amp; lhs, ArgTypes&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) == <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">false</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> any( (__match_comparable_one_of_op(lhs, args)) ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">type_one_of</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;ArgTypes...&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    _type_one_of(Ts&amp;&amp;... args): args(<span class="built_in">std</span>::forward&lt;Ts&gt;(args)...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="built_in">std</span>::<span class="keyword">size_t</span>... I&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op_impl(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup, <span class="built_in">std</span>::index_sequence&lt;I...&gt;) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_one_of_op(lhs, <span class="built_in">std</span>::get&lt;I&gt;(tup)...); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> Inds = <span class="built_in">std</span>::make_index_sequence&lt;<span class="keyword">sizeof</span>...(Ts)&gt;&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_op_impl(lhs, tup, Inds&#123;&#125;); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line">constexpr auto one_of(ArgTypes&amp;&amp;... args) -&gt; _type_one_of&lt;ArgTypes...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _type_one_of&lt;ArgTypes...&gt;(<span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> _type_one_of&lt;ArgTypes...&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.__match_op(lhs, rhs.args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此一來我們就可以用來做更狂的比較，還不會跳 Error 出來：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_in_the_set</span><span class="params">(<span class="keyword">const</span> T&amp; X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(X == one_of(<span class="number">10</span>, </span><br><span class="line">                   <span class="number">23.5465</span>, </span><br><span class="line">                   <span class="string">&quot;Hello&quot;</span>, </span><br><span class="line">                   <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;foo&quot;</span>), </span><br><span class="line">                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&#123;<span class="number">12.5</span>, <span class="number">64.5</span>&#125;,</span><br><span class="line">                   <span class="string">&#x27;c&#x27;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;X is in the set&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    is_in_the_set(<span class="number">10</span>); <span class="comment">//true</span></span><br><span class="line">    is_in_the_set(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">    is_in_the_set(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&#123;<span class="number">0.1</span>, <span class="number">0.2</span>&#125;); <span class="comment">//false</span></span><br><span class="line">    is_in_the_set(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&#123;<span class="number">12.5</span>, <span class="number">64.5</span>&#125;); <span class="comment">//true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Generalization：套用到任意-comparison-operators"><a href="#Generalization：套用到任意-comparison-operators" class="headerlink" title="Generalization：套用到任意 comparison operators"></a>Generalization：套用到任意 comparison operators</h3><p>在上面的例子中我們是針對特定的 operator== 做設計，但是如果因為 one_of 實在太方便，我想要實作 one_of 也可以支援其他 operator 我是不是每次都得重頭設計一遍？其實不用，我們只需要連 operator 都當成是一個 template argument 傳進去就行了！因此開始設計ㄅ！</p>
<p>首先，由於 operator== 沒辦法直接當作 argument 傳入 template，因此我先把 operator== 用 <code>struct _op_equal_to</code> 包起來，並在每一個 template 上都加上一個 Fn 的變態：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">op_equal_to</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">(ArgTypes&amp;&amp;... args)</span> </span>&#123; <span class="keyword">return</span> (... || args); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;&gt;&gt;</span><br><span class="line">struct _whether_support_op : <span class="built_in">std</span>::false_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;LT, RT, std::void_t&lt;</span></span><br><span class="line"><span class="class">        decltype(std::declval&lt;LT&gt;()==std::declval&lt;RT&gt;) &gt;&gt; :</span> <span class="built_in">std</span>::true_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;LT, RT&gt;::value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> lhs</span>==rhs;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_one_of_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> T&amp; lhs, ArgTypes&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) == <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">false</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> any( (__match_comparable_one_of_op(op, lhs, args)) ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">type_one_of</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;ArgTypes...&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    _type_one_of(Ts&amp;&amp;... args): args(<span class="built_in">std</span>::forward&lt;Ts&gt;(args)...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="built_in">std</span>::<span class="keyword">size_t</span>... I&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op_impl(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup, <span class="built_in">std</span>::index_sequence&lt;I...&gt;) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_one_of_op(op, lhs, <span class="built_in">std</span>::get&lt;I&gt;(tup)...); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> Inds = <span class="built_in">std</span>::make_index_sequence&lt;<span class="keyword">sizeof</span>...(Ts)&gt;&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_op_impl(op, lhs, tup, Inds&#123;&#125;); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line">constexpr auto one_of(ArgTypes&amp;&amp;... args) -&gt; _type_one_of&lt;ArgTypes...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _type_one_of&lt;ArgTypes...&gt;(<span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> _type_one_of&lt;ArgTypes...&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.__match_op(_op_equal_to&#123;&#125;, lhs, rhs.args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有加上 <code>TODO</code> 的都是還沒有完成的部份。首先我們已經可以在 <code>__match_comparable_one_of_op</code> 裏面取得用 struct 包好的 operator 的，接下來就是要設計把 <code>op</code> 也傳入 <code>_whether_support_op</code> 裏面檢查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;&gt;&gt;</span><br><span class="line">struct _whether_support_op : <span class="built_in">std</span>::false_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;Fn(Ts...), std::void_t&lt;</span></span><br><span class="line"><span class="class">        decltype(/*TODO*/) &gt;&gt; :</span> <span class="built_in">std</span>::true_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;Fn(LT, RT)&gt;::value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> lhs</span>==rhs;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊注意，我們的 specialized template 只剩下兩格，第一個是 <code>Fn(Ts...)</code>，第二個是<code>std::void_t&lt;&gt;</code>，因此對應的 primary template 的 <code>typename</code> 格數也要剩下兩格。而 <code>std::void_t&lt;&gt;</code> 的內容物還沒設計。</p>
<p>接下來設計 <code>struct _op_equal_to</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">op_equal_to</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line">    constexpr auto operator()(const LT&amp; lhs, const RT&amp; rhs) const -&gt; decltype(std::declval&lt;LT&amp;&gt;() == std::declval&lt;RT&amp;&gt;());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>這邊我使用 overload operator() 來讓 <code>_op_equal_to</code> 變成很像是 function call 的方式來設計，而回傳變態是 <code>decltype(std::declval&lt;LT&amp;&gt;() == std::declval&lt;RT&amp;&gt;())</code>，如果這個東西成立的話，他會變成正確的型態 (通常是 <code>bool</code>)。函式的內容我們不需要定義，剛剛說的，因為我們只會用 <code>decltype</code> 讓 Compiler 檢查 expression 會不會成立而已，我們關心的是那個回傳變態會不會成立，如果成立的話就行了。</p>
<p>接下來就是回到 <code>_whether_support_op</code> 裏面設計 <code>std::void_t&lt;&gt;</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;Fn(Ts...), std::void_t&lt;</span></span><br><span class="line"><span class="class">        decltype( std::declval&lt;Fn&gt;()(std::declval&lt;Ts&gt;()...) ) &gt;&gt; :</span> <span class="built_in">std</span>::true_type</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>這邊我用 <code>std::declval&lt;Fn&gt;()</code> 產生一個 <code>_op_equal_to</code> 的 reference type 並呼叫他的 member function，傳入的參數是一堆 <code>Ts</code> 型態的 reference type <code>std::declval&lt;Ts&gt;()...</code>。</p>
<p>這樣就完成 General 版的 operator supporting 檢查了。</p>
<p>但這邊還有一個問題是，我們真正在比較的地方還沒有 generalize：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;Fn(LT, RT)&gt;::value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> lhs</span>==rhs;  <span class="comment">//here</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>這個地方該怎麼辦？該不會 <code>_op_equal_to</code> 裏面除了有一個虛擬的比較後又要再實作一個單獨的 member function 來做實體的比較？這樣不會太冗嘛？</p>
<p>會。</p>
<p>但是我們只需要動一點手腳就可以做出同時可以虛擬的比較又可以實體的比較的 function 了：<br>首先比較的部份：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;Fn(LT, RT)&gt;::value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">op</span><span class="params">(lhs, rhs)</span></span>;  <span class="comment">//here</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>接下來 <code>_op_equal_to</code> 的部份：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">op_equal_to</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line">    constexpr auto operator()(const LT&amp; lhs, const RT&amp; rhs) const -&gt; decltype(std::declval&lt;LT&amp;&gt;() == std::declval&lt;RT&amp;&gt;())</span><br><span class="line">    &#123; <span class="keyword">return</span> lhs==rhs; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>到這邊就完成了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">op_equal_to</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line">    constexpr auto operator()(const LT&amp; lhs, const RT&amp; rhs) const -&gt; decltype(std::declval&lt;LT&amp;&gt;() == std::declval&lt;RT&amp;&gt;())</span><br><span class="line">    &#123; <span class="keyword">return</span> lhs==rhs; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">(ArgTypes&amp;&amp;... args)</span> </span>&#123; <span class="keyword">return</span> (... || args); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;&gt;&gt;</span><br><span class="line">struct _whether_support_op : <span class="built_in">std</span>::false_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;Fn(Ts...), std::void_t&lt;</span></span><br><span class="line"><span class="class">        decltype( std::declval&lt;Fn&gt;()(std::declval&lt;Ts&gt;()...) ) &gt;&gt; :</span> <span class="built_in">std</span>::true_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;Fn(LT, RT)&gt;::value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">op</span><span class="params">(lhs, rhs)</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_one_of_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> T&amp; lhs, ArgTypes&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) == <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">false</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> any( (__match_comparable_one_of_op(op, lhs, args)) ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">type_one_of</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;ArgTypes...&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    _type_one_of(Ts&amp;&amp;... args): args(<span class="built_in">std</span>::forward&lt;Ts&gt;(args)...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="built_in">std</span>::<span class="keyword">size_t</span>... I&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op_impl(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup, <span class="built_in">std</span>::index_sequence&lt;I...&gt;) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_one_of_op(op, lhs, <span class="built_in">std</span>::get&lt;I&gt;(tup)...); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> Inds = <span class="built_in">std</span>::make_index_sequence&lt;<span class="keyword">sizeof</span>...(Ts)&gt;&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Ts...&gt; &amp;tup) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> __match_op_impl(op, lhs, tup, Inds&#123;&#125;); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line">constexpr auto one_of(ArgTypes&amp;&amp;... args) -&gt; _type_one_of&lt;ArgTypes...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _type_one_of&lt;ArgTypes...&gt;(<span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> _type_one_of&lt;ArgTypes...&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.__match_op(_op_equal_to&#123;&#125;, lhs, rhs.args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下來就可以嘗試定義其他 operators</p>
<ul>
<li><p><code>operator!=</code> ，這東西沒有什麼好定義的，把 <code>operator==</code> 前面加上 <code>!</code> 就好了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> _type_one_of&lt;ArgTypes...&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !rhs.__match_op(_op_equal_to&#123;&#125;, lhs, rhs.args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>operator&lt;</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">op_less_than</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line">    constexpr auto operator()(const LT&amp; lhs, const RT&amp; rhs) const -&gt; decltype(std::declval&lt;LT&amp;&gt;() &lt; std::declval&lt;RT&amp;&gt;())</span><br><span class="line">    &#123; <span class="keyword">return</span> lhs &lt; rhs; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> _type_one_of&lt;ArgTypes...&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.__match_op(_op_less_than&#123;&#125;, lhs, rhs.args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他自己試</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://godbolt.org/z/wjmLZI">完整的測試 Code</a></p>
<h3 id="其他討論"><a href="#其他討論" class="headerlink" title="其他討論"></a>其他討論</h3><h4 id="op-equal-to-的其他寫法"><a href="#op-equal-to-的其他寫法" class="headerlink" title="_op_equal_to 的其他寫法"></a><code>_op_equal_to</code> 的其他寫法</h4><p>其實 <code>_op_equal_to</code> 這個 struct 還有其他寫法，例如也可以把 decltype 寫到 template 裏面判斷：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">op_equal_to</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT, <span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;LT&amp;&gt;() == <span class="built_in">std</span>::declval&lt;RT&amp;&gt;())&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs) <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> lhs==rhs; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>設在 template 的第三個 parameter，然後把 <code>auto</code> 換成 <code>bool</code>。但是我覺得這樣沒有比較好的原因是，<code>lhs==rhs</code> 並沒有保證回傳值一定是 <code>bool</code>。雖然在 comparison 裏面回傳非 <code>bool</code> 值本身就很奇怪。</p>
<h4 id="冗字"><a href="#冗字" class="headerlink" title="冗字"></a>冗字</h4><p>後來發現其實有些地方的 <code>std::forward</code> 可以拿掉。</p>
<p>第一個就是 <code>one_of</code> 裏面呼叫 <code>_type_one_of</code> 的 constructor<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line">constexpr auto one_of(ArgTypes&amp;&amp;... args) -&gt; _type_one_of&lt;ArgTypes...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _type_one_of&lt;ArgTypes...&gt;(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因為 parameter pack 傳到 parameter pack 直接用 <code>...</code> unpack 就行了。</p>
<p>第二個是 <code>_type_one_of</code> 的 constructor 裏面呼叫 tuple 的 constructor<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    _type_one_of(Ts&amp;&amp;... args): args(args...) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>實際上應該還有其他地方可以簡化，只是目前還沒有更多想法。</p>
<h4 id="function-type-的-SFINAE"><a href="#function-type-的-SFINAE" class="headerlink" title="function type 的 SFINAE"></a>function type 的 SFINAE</h4><p>有些人可能會以為要用 <code>std::void_t</code> 才能玩 SFINAE，其實 SFINAE 也不是什麼新概念了，而是因為有了這個概念，才會在 c++ 17 裏面新增 <code>std::void_t</code> 這個東西。在這之前其實也是可以用類似的方法實現 SFINAE，其中一種方式就是用 function 的方式。</p>
<p>這邊示範怎麼用 function type 來寫 SFINAE，首先這是原本 struct type 的 SFINAE<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;&gt;&gt;</span><br><span class="line">struct _whether_support_op : <span class="built_in">std</span>::false_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;Fn(Ts...), std::void_t&lt;</span></span><br><span class="line"><span class="class">        decltype( std::declval&lt;Fn&gt;()(std::declval&lt;Ts&gt;()...) ) &gt;&gt; :</span> <span class="built_in">std</span>::true_type</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>這邊來定義 <code>__whether_support_op</code> function definition (不需要 function 實體)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> = <span class="keyword">decltype</span>( <span class="built_in">std</span>::declval&lt;Fn&gt;()(<span class="built_in">std</span>::declval&lt;Ts&gt;()...) )&gt;</span><br><span class="line"><span class="built_in">std</span>::true_type __whether_support_op(<span class="keyword">const</span> Fn&amp;, <span class="keyword">const</span> Ts&amp;...);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::false_type __whether_support_op(...);</span><br></pre></td></tr></table></figure></p>
<p>感覺比 struct type 的 SFINAE 更簡單易懂。</p>
<p>可以看的出來，同樣道理，如果第一個 template function 的第三個 template parameter 成立，我們可以得到 return type 為 <code>std::true_type</code> 的 function，如果不成立，則配對到 return type 為 <code>std::false_type</code> 的 function，然後傳進去的參數就像是垃圾一樣隨便包成一包 parameter pack <code>...</code>。</p>
<p>接著把呼叫的地方改掉：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">decltype</span>(__whether_support_op(<span class="built_in">std</span>::declval&lt;Fn&gt;(), <span class="built_in">std</span>::declval&lt;LT&gt;(), <span class="built_in">std</span>::declval&lt;RT&gt;()))::value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">op</span><span class="params">(lhs, rhs)</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先 <code>__whether_support_op</code> 是一個 function，我們可以藉由傳入參數的 reference type <code>std::declval&lt;&gt;</code> 來讓 Compiler 驗證 function。然後用 <code>decltype()</code> 取得 function 的 return type。最後再取出 <code>value</code> 值看看是 <code>true</code> 還是 <code>false</code>。記住！使用 <code>decltype()</code> 呼叫 function，Compiler 不會執行 function 實體，因此我們只需要有 function definition 就好了。</p>
<p>但是這邊我們就使用了一個很醜的方式呼叫我們的 function。實際上我們也可以用漂亮一點的方式，再包一層 SFINAE 的 struct helper：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;Fn(Ts...)&gt; :</span> <span class="keyword">decltype</span>(__whether_support_op(<span class="built_in">std</span>::declval&lt;Fn&gt;(), <span class="built_in">std</span>::declval&lt;Ts&gt;()...))</span><br></pre></td></tr></table></figure></p>
<p>然後呼叫的部份改成原本的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;Fn(LT, RT)&gt;::value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">op</span><span class="params">(lhs, rhs)</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的 function type SFINAE：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> = <span class="keyword">decltype</span>( <span class="built_in">std</span>::declval&lt;Fn&gt;()(<span class="built_in">std</span>::declval&lt;Ts&gt;()...) )&gt;</span><br><span class="line"><span class="built_in">std</span>::true_type __whether_support_op(<span class="keyword">const</span> Fn&amp;, <span class="keyword">const</span> Ts&amp;...);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::false_type __whether_support_op(...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;Fn(Ts...)&gt; :</span> <span class="keyword">decltype</span>(__whether_support_op(<span class="built_in">std</span>::declval&lt;Fn&gt;(), <span class="built_in">std</span>::declval&lt;Ts&gt;()...))</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;Fn(LT, RT)&gt;::value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">op</span><span class="params">(lhs, rhs)</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>跟單純只用 struct type 的 SFINAE 比起來相對就比較冗一點：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;&gt;&gt;</span><br><span class="line">struct _whether_support_op : <span class="built_in">std</span>::false_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">whether_support_op</span>&lt;Fn(Ts...), std::void_t&lt;decltype( std::declval&lt;Fn&gt;()(std::declval&lt;Ts&gt;()...) ) &gt;&gt; :</span> <span class="built_in">std</span>::true_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> LT, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> __match_comparable_one_of_op(<span class="keyword">const</span> Fn&amp; op, <span class="keyword">const</span> LT&amp; lhs, <span class="keyword">const</span> RT&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(_whether_support_op&lt;Fn(LT, RT)&gt;::value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">op</span><span class="params">(lhs, rhs)</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以我才會使用 struct type 的 SFINAE。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相關文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/09/02/position-based-fluids-note/" rel="bookmark">[Note] Position Based Fluids</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/09/02/auto-note/" rel="bookmark">[Note] AuTO: Scaling Deep Reinforcement Learnign for Datacenter-Scale Automatic Traffic Optimization</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Note/" rel="tag"><i class="fa fa-tag"></i> Note</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/Metaprogramming/" rel="tag"><i class="fa fa-tag"></i> Metaprogramming</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/09/02/position-based-fluids-note/" rel="next" title="[Note] Position Based Fluids">
      [Note] Position Based Fluids <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%99%BC%E6%83%B3"><span class="nav-text">發想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A8%99"><span class="nav-text">目標</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%A6%E7%8F%BE"><span class="nav-text">實現</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%B2%E9%9A%8E"><span class="nav-text">進階</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9A%E6%AF%94%E8%BC%83%E6%B8%AC%E8%A9%A6"><span class="nav-text">做比較測試</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generalization%EF%BC%9A%E5%A5%97%E7%94%A8%E5%88%B0%E4%BB%BB%E6%84%8F-comparison-operators"><span class="nav-text">Generalization：套用到任意 comparison operators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%A8%8E%E8%AB%96"><span class="nav-text">其他討論</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#op-equal-to-%E7%9A%84%E5%85%B6%E4%BB%96%E5%AF%AB%E6%B3%95"><span class="nav-text">_op_equal_to 的其他寫法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%97%E5%AD%97"><span class="nav-text">冗字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function-type-%E7%9A%84-SFINAE"><span class="nav-text">function type 的 SFINAE</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Joe Hsiao"
      src="https://i.imgur.com/TBCKPn1.jpg">
  <p class="site-author-name" itemprop="name">Joe Hsiao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ending2015a" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ending2015a" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/hsiao.ending" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;hsiao.ending" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/tsu-ching-hsiao-207710171/" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;tsu-ching-hsiao-207710171&#x2F;" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i>LinkedIn</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/channel/UCxQE_77aDje2oGwaYWfUBYw" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCxQE_77aDje2oGwaYWfUBYw" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:joehsiao@gapp.nthu.edu.tw" title="E-Mail → mailto:joehsiao@gapp.nthu.edu.tw" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
    <div class="google-ads sidebar-inner" style="display:block; ">
      <!-- Google AdSense Start -->
      
      <!-- Google AdSense End -->
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fas fa-bomb"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joe Hsiao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="總字數">61k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="所需總閱讀時間">2:31</span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        




  <script src="https://www.gstatic.com/firebasejs/6.3.3/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/6.3.3/firebase-firestore.js"></script>
  <script>
    firebase.initializeApp({
      apiKey   : 'AIzaSyAh0yiA4K7UmvnkI3uec5UzR-6l0Iqx4_E',
      projectId: 'hexo-blog-my-notes'
    });

    function getCount(doc, increaseCount) {
      // IncreaseCount will be false when not in article page
      return doc.get().then(d => {
        var count = 0;
        if (!d.exists) { // Has no data, initialize count
          if (increaseCount) {
            doc.set({
              count: 1
            });
            count = 1;
          }
        } else { // Has data
          count = d.data().count;
          if (increaseCount) {
            // If first view this article
            doc.set({ // Increase count
              count: count + 1
            });
            count++;
          }
        }

        return count;
      });
    }

    function appendCountTo(el) {
      return count => {
        el.innerText = count;
      }
    }
  </script>
  <script data-pjax>
    (function() {
      var db = firebase.firestore();
      var articles = db.collection('articles');

      if (CONFIG.page.isPost) { // Is article page
        var title = document.querySelector('.post-title').innerText.trim();
        var doc = articles.doc(title);
        var increaseCount = CONFIG.hostname === location.hostname;
        if (localStorage.getItem(title)) {
          increaseCount = false;
        } else {
          // Mark as visited
          localStorage.setItem(title, true);
        }
        getCount(doc, increaseCount).then(appendCountTo(document.querySelector('.firestore-visitors-count')));
      } else if (CONFIG.page.isHome) { // Is index page
        var promises = [...document.querySelectorAll('.post-title')].map(element => {
          var title = element.innerText.trim();
          var doc = articles.doc(title);
          return getCount(doc);
        });
        Promise.all(promises).then(counts => {
          var metas = document.querySelectorAll('.firestore-visitors-count');
          counts.forEach((val, idx) => {
            appendCountTo(metas[idx])(val);
          });
        });
      }
    })();
  </script>




      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '147625b156bb26bc2600',
      clientSecret: '5b28b32d768ce289add547b43f2a144274dec2a8',
      repo        : 'Ending2015a.github.io',
      owner       : 'Ending2015a',
      admin       : ['Ending2015a'],
      id          : '9b7e20bbcef3ccf48c12b5c319cc1b00',
        language: 'zh-TW',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
